# 本程序的开发文档

## 1.程序简介:
此程序是中国科学院大学2024级程序设计基础与实验（C语言）课程的课程作业，实现了一个支持PVE(人机对战)与PVP(人人对战)两种模式，使用简化版禁手规则的C语言五子棋程序

---------------------------------------

## 2.关于程序使用方法

### 2.1 Linux（bash）环境下：
在终端输入：<br>
`make`<br>

若编译成功，终端应显示：<br>
`编译成功，生成可执行文件：gomoku`<br>

在终端输入：<br>
`./gomoku`<br>
运行游戏；游戏的进行在游戏内有详细提示<br>

在终端输入：<br>
`make clean`<br>
清除所有编译文件<br>

### 2.2 Windows（powershell）环境下：
在终端输入：<br>
`make`<br>

若编译成功，终端应显示：<br>
`编译成功，生成可执行文件：gomoku.exe`<br>

在终端输入：<br>
`.\gomoku`<br>
或点击可执行文件`gomoku.exe`来运行游戏；游戏的进行在游戏内有详细提示<br>

在终端输入：<br>
`make clean`<br>
清除所有编译文件<br>

---------------------------------------

## 3.关于代码结构

### 3.1 头文件
包含`gomoku.h`，声明了一些函数，全局变量和宏常量，便于维护<br>

### 3.2 Main
包含`main.c`，是程序的主函数，主要功能是处理玩家输入并进行合法性检查，调用其他函数完成输出，并更新游戏状态<br>

### 3.3 Boardprint
包含`boardprint.c`，`boardreset.c`和`emptyboardprint.c`，分别实现了：根据落子打印并更新棋盘；将棋盘重置为空棋盘；打印空棋盘的功能<br>

### 3.4 Wincheck
包含`wincheck.c`和`wincheckforai.c`，实现了通过检查上一步落子来判断是否有一方胜利，并更新游戏状态；为ai决策判断是否有一方胜利的功能<br>

### 3.5 Shapecheck
包含`twocheck.c`，`threecheck.c`，`fourcheck.c`，`fivecheck.c`和`fivepluscheck.c`，分别实现了检测**在某空位上落子，可以形成的各种二连/三连/四连/五连/长连数**的功能<br>

### 3.6 Bancheck
包含`bancheck.c`和`banreset.c`，分别实现了：通过调用`Shapecheck`中的函数来检测**在某空位上落子，是否会形成禁手**并将每点的禁手状态记录在一个数组中；重置棋盘上每点禁手状态的功能<br>

### 3.7 Mark
包含`mark.c`和`scorereset.c`，分别实现了：通过调用`Shapecheck`和`Bancheck`中的函数来评估**某空位对于黑方/白方的重要性**并将其量化为分数记录在一个数组中；重置棋盘上每点分数的功能<br>

### 3.8 AImove
包含`findtopscore.c`，`decisiontree.c`和`aimove.c`，分别实现了：根据决策方检查棋盘得分并找出**黑白双方的相加的总得分最高**的若干个点；将`findtopscore`的结果作为候选点，通过博弈递归累加得分进一步判断候选点价值；调用`decisiontree`进行最终决策的功能<br>

---------------------------------------

## 4.关于算法
### 4.1 棋型判断
分别向四个方向检索，数出正负方向上直到遇到异色棋子/边界/空位的某色棋子的数量<br>
前期完成的函数中，使用枚举实现不同方向的检测；后期使用数组'dr[] dc[]'实现<br>

### 4.2 打分
对于一个空位，对其进行棋型判断，通过**在该空位上落子，可以形成的**棋型的种类和数量乘以相应的权重并累加来判断该空位的重要程度<br>
累加时，同时统计本色棋和异色棋的得分，对异色棋的得分乘以宏常量**DEFENDFACTOR**，来调节AI的进攻/防守偏好<br>
对于一些必须防守/进攻的空位，加以极大的分数来凸显其重要性<br>
所有分数权重均为宏常量，便于维护<br>

### 4.3 AI决策
首先，通过`findtopscore`找出目前总得分最高的几个空位，供决策树进行深层推理，在尽可能保证决策广度的前提下加深了决策深度<br>
在`decisiontree`中，对找出的得分最高的几个空位依次进行多层博弈推理<br>
推理过程：调用`findtopscore`，在找出的某个空位上落子；之后以另一方的视角，再次调用`findtopscore`，找出空位并落子，并将剩余层数减一；不断重复，直到层数耗尽<br>
每次某方落子，都会通过`mark`打分并对该方的分数进行累加（黑方累加，白方累减），遍历所有路径后可得出该方能得到的最大/最小的分数<br>
期间，若有一条路径出现某方胜利的情况，会给这条路径赋最大/最小总分，凸显其重要性 *此做法在具体实现中出现问题，暂时弃用*<br>
这样可以确保博弈推理中，每一方都在尽量下出算法认为最好的那步棋<br>
在`aimove`中，以`findtopscore`找出的若干空位为根节点，依次调用`decisiontree`，为黑方找出累计分数最高的位置，为白方找出累计分数最低的位置；这就是算法认为对该方最重要的位置<br>

---------------------------------------

*开发过程，Debug记录可见`Devdairy_Gomoku.txt`*<br>